{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTableState.js","../src/hooks/useTable.js","../src/hooks/useColumns.js","../src/hooks/useRows.js","../src/actions.js","../src/hooks/useExpanded.js","../src/hooks/useFilters.js","../src/aggregations.js","../src/hooks/useGroupBy.js","../src/hooks/useSortBy.js","../src/hooks/usePagination.js","../src/hooks/useFlexLayout.js","../src/hooks/useTokenPagination.js"],"sourcesContent":["import React from 'react'\r\n\r\nexport function getBy(obj, path, def) {\r\n  if (!path) {\r\n    return obj\r\n  }\r\n  const pathObj = makePathArray(path)\r\n  let val\r\n  try {\r\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\r\n  } catch (e) {\r\n    // continue regardless of error\r\n  }\r\n  return typeof val !== 'undefined' ? val : def\r\n}\r\n\r\nexport function defaultOrderByFn(arr, funcs, dirs) {\r\n  return [...arr].sort((rowA, rowB) => {\r\n    for (let i = 0; i < funcs.length; i += 1) {\r\n      const sortFn = funcs[i]\r\n      const desc = dirs[i] === false || dirs[i] === 'desc'\r\n      const sortInt = sortFn(rowA, rowB)\r\n      if (sortInt !== 0) {\r\n        return desc ? -sortInt : sortInt\r\n      }\r\n    }\r\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\r\n  })\r\n}\r\n\r\nexport function defaultSortByFn(a, b, desc) {\r\n  // force null and undefined to the bottom\r\n  a = a === null || a === undefined ? '' : a\r\n  b = b === null || b === undefined ? '' : b\r\n  // force any string values to lowercase\r\n  a = typeof a === 'string' ? a.toLowerCase() : a\r\n  b = typeof b === 'string' ? b.toLowerCase() : b\r\n  // Return either 1 or -1 to indicate a sort priority\r\n  if (a > b) {\r\n    return 1\r\n  }\r\n  if (a < b) {\r\n    return -1\r\n  }\r\n  // returning 0, undefined or any falsey value will defer to the next\r\n  // sorting mechanism or eventually the columns index via the orderByFn\r\n  return 0\r\n}\r\n\r\nexport function getFirstDefined(...args) {\r\n  for (let i = 0; i < args.length; i += 1) {\r\n    if (typeof args[i] !== 'undefined') {\r\n      return args[i]\r\n    }\r\n  }\r\n}\r\n\r\nexport function defaultGroupByFn(rows, grouper) {\r\n  return rows.reduce((prev, row, i) => {\r\n    const resKey =\r\n      typeof grouper === 'function'\r\n        ? grouper(row.values, i)\r\n        : row.values[grouper]\r\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\r\n    prev[resKey].push(row)\r\n    return prev\r\n  }, {})\r\n}\r\n\r\nexport function defaultFilterFn(row, id, value, column) {\r\n  return row.values[id] !== undefined\r\n    ? String(row.values[id])\r\n      .toLowerCase()\r\n      .includes(String(value).toLowerCase())\r\n    : true\r\n}\r\n\r\nexport function setBy(obj = {}, path, value) {\r\n  const recurse = (obj, depth = 0) => {\r\n    const key = path[depth]\r\n    const target = typeof obj[key] !== 'object' ? {} : obj[key]\r\n    const subValue =\r\n      depth === path.length - 1 ? value : recurse(target, depth + 1)\r\n    return {\r\n      ...obj,\r\n      [key]: subValue\r\n    }\r\n  }\r\n\r\n  return recurse(obj)\r\n}\r\n\r\nexport function getElementDimensions(element) {\r\n  const rect = element.getBoundingClientRect()\r\n  const style = window.getComputedStyle(element)\r\n  const margins = {\r\n    left: parseInt(style.marginLeft),\r\n    right: parseInt(style.marginRight)\r\n  }\r\n  const padding = {\r\n    left: parseInt(style.paddingLeft),\r\n    right: parseInt(style.paddingRight)\r\n  }\r\n  return {\r\n    left: Math.ceil(rect.left),\r\n    width: Math.ceil(rect.width),\r\n    outerWidth: Math.ceil(\r\n      rect.width + margins.left + margins.right + padding.left + padding.right\r\n    ),\r\n    marginLeft: margins.left,\r\n    marginRight: margins.right,\r\n    paddingLeft: padding.left,\r\n    paddingRight: padding.right,\r\n    scrollWidth: element.scrollWidth\r\n  }\r\n}\r\n\r\nexport function flexRender(Comp, props) {\r\n  if (typeof Comp === 'function') {\r\n    return Object.getPrototypeOf(Comp).isReactComponent ? (\r\n      <Comp {...props} />\r\n    ) : (\r\n      Comp(props)\r\n    )\r\n  }\r\n  return Comp\r\n}\r\n\r\nexport const mergeProps = (...groups) => {\r\n  let props = {}\r\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\r\n    props = {\r\n      ...props,\r\n      ...rest,\r\n      style: {\r\n        ...(props.style || {}),\r\n        ...style\r\n      },\r\n      className: [props.className, className].filter(Boolean).join(' ')\r\n    }\r\n  })\r\n  return props\r\n}\r\n\r\nexport const applyHooks = (hooks, initial, ...args) =>\r\n  hooks.reduce((prev, next) => next(prev, ...args), initial)\r\n\r\nexport const applyPropHooks = (hooks, ...args) =>\r\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\r\n\r\nexport const warnUnknownProps = props => {\r\n  if (Object.keys(props).length) {\r\n    throw new Error(\r\n      `Unknown options passed to useReactTable:\r\n      \r\n${JSON.stringify(props, null, 2)}`\r\n    )\r\n  }\r\n}\r\n\r\nexport function sum(arr) {\r\n  return arr.reduce((prev, curr) => prev + curr, 0)\r\n}\r\n\r\nfunction makePathArray(obj) {\r\n  return flattenDeep(obj)\r\n    .join('.')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.')\r\n}\r\n\r\nfunction flattenDeep(arr, newArr = []) {\r\n  if (!Array.isArray(arr)) {\r\n    newArr.push(arr)\r\n  } else {\r\n    for (let i = 0; i < arr.length; i += 1) {\r\n      flattenDeep(arr[i], newArr)\r\n    }\r\n  }\r\n  return newArr\r\n}\r\n","import { useState, useMemo } from 'react'\r\n\r\nexport const defaultState = {}\r\n\r\nconst defaultReducer = (old, newState) => newState\r\n\r\nexport const useTableState = (\r\n  initialState = {},\r\n  overrides = {},\r\n  { reducer = defaultReducer, useState: userUseState = useState } = {}\r\n) => {\r\n  let [state, setState] = userUseState({\r\n    ...defaultState,\r\n    ...initialState\r\n  })\r\n\r\n  const overriddenState = useMemo(() => {\r\n    const newState = {\r\n      ...state\r\n    }\r\n    Object.keys(overrides).forEach(key => {\r\n      newState[key] = overrides[key]\r\n    })\r\n    return newState\r\n  }, [state, ...Object.values(overrides)])\r\n\r\n  const reducedSetState = (updater, type) =>\r\n    setState(old => {\r\n      const newState = updater(old)\r\n      return reducer(old, newState, type)\r\n    })\r\n\r\n  return [overriddenState, reducedSetState]\r\n}\r\n","import PropTypes from 'prop-types'\r\n//\r\nimport { flexRender, applyHooks, applyPropHooks, mergeProps } from '../utils'\r\n\r\nimport { useTableState } from './useTableState'\r\n\r\nconst renderErr =\r\n  'You must specify a render \"type\". This could be \"Header\", \"Filter\", or any other custom renderers you have set on your column.'\r\n\r\nconst propTypes = {\r\n  // General\r\n  data: PropTypes.array.isRequired,\r\n  debug: PropTypes.bool\r\n}\r\n\r\nexport const useTable = (props, ...plugins) => {\r\n  // Validate props\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\r\n\r\n  // Destructure props\r\n  let { data = [], state: userState, debug } = props\r\n\r\n  debug = process.env.NODE_ENV === 'production' ? false : debug\r\n\r\n  // Always provide a default state\r\n  const defaultState = useTableState()\r\n\r\n  // But use the users state if provided\r\n  const state = userState || defaultState\r\n\r\n  // These are hooks that plugins can use right before render\r\n  const hooks = {\r\n    beforeRender: [],\r\n    columns: [],\r\n    headers: [],\r\n    headerGroups: [],\r\n    rows: [],\r\n    row: [],\r\n    renderableRows: [],\r\n    getTableProps: [],\r\n    getRowProps: [],\r\n    getHeaderRowProps: [],\r\n    getHeaderProps: [],\r\n    getCellProps: []\r\n  }\r\n\r\n  // The initial api\r\n  let api = {\r\n    ...props,\r\n    data,\r\n    state,\r\n    hooks\r\n  }\r\n\r\n  if (debug) console.time('hooks')\r\n  // Loop through plugins to build the api out\r\n  api = plugins.filter(Boolean).reduce((prev, next) => next(prev), api)\r\n  if (debug) console.timeEnd('hooks')\r\n\r\n  // Run the beforeRender hook\r\n  if (debug) console.time('hooks.beforeRender')\r\n  applyHooks(api.hooks.beforeRender, undefined, api)\r\n  if (debug) console.timeEnd('hooks.beforeRender')\r\n\r\n  if (debug) console.time('hooks.columns')\r\n  api.columns = applyHooks(api.hooks.columns, api.columns, api)\r\n  if (debug) console.timeEnd('hooks.columns')\r\n\r\n  if (debug) console.time('hooks.headers')\r\n  api.headers = applyHooks(api.hooks.headers, api.headers, api)\r\n  if (debug) console.timeEnd('hooks.headers')\r\n  ;[...api.columns, ...api.headers].forEach(column => {\r\n    // Give columns/headers rendering power\r\n    column.render = (type, userProps = {}) => {\r\n      if (!type) {\r\n        throw new Error(renderErr)\r\n      }\r\n      return flexRender(column[type], {\r\n        ...api,\r\n        ...column,\r\n        ...userProps\r\n      })\r\n    }\r\n\r\n    // Give columns/headers getHeaderProps\r\n    column.getHeaderProps = props =>\r\n      mergeProps(\r\n        {\r\n          key: ['header', column.id].join('_')\r\n        },\r\n        applyPropHooks(api.hooks.getHeaderProps, column, api),\r\n        props\r\n      )\r\n  })\r\n\r\n  if (debug) console.time('hooks.headerGroups')\r\n  api.headerGroups = applyHooks(\r\n    api.hooks.headerGroups,\r\n    api.headerGroups,\r\n    api\r\n  ).filter((headerGroup, i) => {\r\n    // Filter out any headers and headerGroups that don't have visible columns\r\n    headerGroup.headers = headerGroup.headers.filter(header => {\r\n      const recurse = columns =>\r\n        columns.filter(column => {\r\n          if (column.columns) {\r\n            return recurse(column.columns)\r\n          }\r\n          return column.visible\r\n        }).length\r\n      if (header.columns) {\r\n        return recurse(header.columns)\r\n      }\r\n      return header.visible\r\n    })\r\n\r\n    // Give headerGroups getRowProps\r\n    if (headerGroup.headers.length) {\r\n      headerGroup.getRowProps = (props = {}) =>\r\n        mergeProps(\r\n          {\r\n            key: [`header${i}`].join('_')\r\n          },\r\n          applyPropHooks(api.hooks.getHeaderRowProps, headerGroup, api),\r\n          props\r\n        )\r\n      return true\r\n    }\r\n\r\n    return false\r\n  })\r\n  if (debug) console.timeEnd('hooks.headerGroups')\r\n\r\n  // Run the rows (this could be a dangerous hook with a ton of data)\r\n  if (debug) console.time('hooks.rows')\r\n  api.rows = applyHooks(api.hooks.rows, api.rows, api)\r\n  if (debug) console.timeEnd('hooks.rows')\r\n\r\n  // This function is absolutely necessary and MUST be called on\r\n  // any rows the user wishes to be displayed.\r\n  api.prepareRow = row => {\r\n    const { path } = row\r\n    row.getRowProps = props =>\r\n      mergeProps(\r\n        { key: ['row', path].join('_') },\r\n        applyHooks(api.hooks.getRowProps, row, api),\r\n        props\r\n      )\r\n\r\n    // need to apply any row specific hooks (useExpanded requires this)\r\n    applyHooks(api.hooks.row, row, api)\r\n    \r\n    row.cells = row.cells.filter(cell => cell.column.visible)\r\n\r\n    row.cells.forEach(cell => {\r\n      if (!cell) {\r\n        return\r\n      }\r\n\r\n      const { column } = cell\r\n\r\n      cell.getCellProps = props => {\r\n        const columnPathStr = [path, column.id].join('_')\r\n        return mergeProps(\r\n          {\r\n            key: ['cell', columnPathStr].join('_')\r\n          },\r\n          applyPropHooks(api.hooks.getCellProps, cell, api),\r\n          props\r\n        )\r\n      }\r\n\r\n\r\n      cell.render = (type, userProps = {}) => {\r\n        if (!type) {\r\n          throw new Error(\r\n            'You must specify a render \"type\". This could be \"Cell\", \"Header\", \"Filter\", \"Aggregated\" or any other custom renderers you have set on your column.'\r\n          )\r\n        }\r\n        return flexRender(column[type], {\r\n          ...api,\r\n          ...cell,\r\n          ...userProps\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  api.getTableProps = userProps =>\r\n    mergeProps(applyPropHooks(api.hooks.getTableProps, api), userProps)\r\n\r\n  api.getRowProps = userProps =>\r\n    mergeProps(applyPropHooks(api.hooks.getRowProps, api), userProps)\r\n\r\n  return api\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport { getBy } from '../utils'\r\n\r\nconst propTypes = {\r\n  // General\r\n  columns: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      Cell: PropTypes.any,\r\n      Header: PropTypes.any\r\n    })\r\n  )\r\n}\r\n\r\nexport const useColumns = props => {\r\n  const {\r\n    debug,\r\n    columns: userColumns,\r\n    state: [{ groupBy }]\r\n  } = props\r\n\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useColumns')\r\n\r\n  const { columns, headerGroups, headers } = useMemo(() => {\r\n    if (debug) console.info('getColumns')\r\n\r\n    // Decorate All the columns\r\n    let columnTree = decorateColumnTree(userColumns)\r\n\r\n    // Get the flat list of all columns\r\n    let columns = flattenBy(columnTree, 'columns')\r\n\r\n    columns = [\r\n      ...groupBy.map(g => columns.find(col => col.id === g)),\r\n      ...columns.filter(col => !groupBy.includes(col.id))\r\n    ]\r\n\r\n    // Get headerGroups\r\n    const headerGroups = makeHeaderGroups(columns, findMaxDepth(columnTree))\r\n    const headers = flattenBy(headerGroups, 'headers')\r\n\r\n    return {\r\n      columns,\r\n      headerGroups,\r\n      headers\r\n    }\r\n  }, [groupBy, userColumns])\r\n\r\n  return {\r\n    ...props,\r\n    columns,\r\n    headerGroups,\r\n    headers\r\n  }\r\n\r\n  // Find the depth of the columns\r\n  function findMaxDepth(columns, depth = 0) {\r\n    return columns.reduce((prev, curr) => {\r\n      if (curr.columns) {\r\n        return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\r\n      }\r\n      return depth\r\n    }, 0)\r\n  }\r\n\r\n  function decorateColumn(column, parent) {\r\n    // First check for string accessor\r\n    let { id, accessor, Header } = column\r\n\r\n    if (typeof accessor === 'string') {\r\n      id = id || accessor\r\n      const accessorString = accessor\r\n      accessor = row => getBy(row, accessorString)\r\n    }\r\n\r\n    if (!id && typeof Header === 'string') {\r\n      id = Header\r\n    }\r\n\r\n    if (!id) {\r\n      // Accessor, but no column id? This is bad.\r\n      console.error(column)\r\n      throw new Error('A column id is required!')\r\n    }\r\n\r\n    column = {\r\n      Header: '',\r\n      Cell: cell => cell.value,\r\n      show: true,\r\n      ...column,\r\n      id,\r\n      accessor,\r\n      parent\r\n    }\r\n\r\n    return column\r\n  }\r\n\r\n  // Build the visible columns, headers and flat column list\r\n  function decorateColumnTree(columns, parent, depth = 0) {\r\n    return columns.map(column => {\r\n      column = decorateColumn(column, parent)\r\n      if (column.columns) {\r\n        column.columns = decorateColumnTree(column.columns, column, depth + 1)\r\n      }\r\n      return column\r\n    })\r\n  }\r\n\r\n  function flattenBy(columns, childKey) {\r\n    const flatColumns = []\r\n\r\n    const recurse = columns => {\r\n      columns.forEach(d => {\r\n        if (!d[childKey]) {\r\n          flatColumns.push(d)\r\n        } else {\r\n          recurse(d[childKey])\r\n        }\r\n      })\r\n    }\r\n\r\n    recurse(columns)\r\n\r\n    return flatColumns\r\n  }\r\n\r\n  // Build the header groups from the bottom up\r\n  function makeHeaderGroups(columns, maxDepth) {\r\n    const headerGroups = []\r\n\r\n    const removeChildColumns = column => {\r\n      delete column.columns\r\n      if (column.parent) {\r\n        removeChildColumns(column.parent)\r\n      }\r\n    }\r\n    columns.forEach(removeChildColumns)\r\n\r\n    const buildGroup = (columns, depth = 0) => {\r\n      const headerGroup = {\r\n        headers: []\r\n      }\r\n\r\n      const parentColumns = []\r\n\r\n      const hasParents = columns.some(col => col.parent)\r\n\r\n      columns.forEach(column => {\r\n        const isFirst = !parentColumns.length\r\n        let latestParentColumn = [...parentColumns].reverse()[0]\r\n\r\n        // If the column has a parent, add it if necessary\r\n        if (column.parent) {\r\n          if (isFirst || latestParentColumn.originalID !== column.parent.id) {\r\n            parentColumns.push({\r\n              ...column.parent,\r\n              originalID: column.parent.id,\r\n              id: [column.parent.id, parentColumns.length].join('_')\r\n            })\r\n          }\r\n        } else if (hasParents) {\r\n          // If other columns have parents, add a place holder if necessary\r\n          const placeholderColumn = decorateColumn({\r\n            originalID: [column.id, 'placeholder', maxDepth - depth].join('_'),\r\n            id: [\r\n              column.id,\r\n              'placeholder',\r\n              maxDepth - depth,\r\n              parentColumns.length\r\n            ].join('_')\r\n          })\r\n          if (\r\n            isFirst ||\r\n            latestParentColumn.originalID !== placeholderColumn.originalID\r\n          ) {\r\n            parentColumns.push(placeholderColumn)\r\n          }\r\n        }\r\n\r\n        // Establish the new columns[] relationship on the parent\r\n        if (column.parent || hasParents) {\r\n          latestParentColumn = [...parentColumns].reverse()[0]\r\n          latestParentColumn.columns = latestParentColumn.columns || []\r\n          if (!latestParentColumn.columns.includes(column)) {\r\n            latestParentColumn.columns.push(column)\r\n          }\r\n        }\r\n\r\n        headerGroup.headers.push(column)\r\n      })\r\n\r\n      headerGroups.push(headerGroup)\r\n\r\n      if (parentColumns.length) {\r\n        buildGroup(parentColumns)\r\n      }\r\n    }\r\n\r\n    buildGroup(columns)\r\n\r\n    return headerGroups.reverse()\r\n  }\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nconst propTypes = {\r\n  subRowsKey: PropTypes.string\r\n}\r\n\r\nexport const useRows = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useRows')\r\n\r\n  const { debug, columns, subRowsKey = 'subRows', data } = props\r\n\r\n  const accessedRows = useMemo(() => {\r\n    if (debug) console.info('getAccessedRows')\r\n\r\n    // Access the row's data\r\n    const accessRow = (originalRow, i, depth = 0) => {\r\n      // Keep the original reference around\r\n      const original = originalRow\r\n\r\n      // Process any subRows\r\n      const subRows = originalRow[subRowsKey]\r\n        ? originalRow[subRowsKey].map((d, i) => accessRow(d, i, depth + 1))\r\n        : undefined\r\n\r\n      const row = {\r\n        original,\r\n        index: i,\r\n        subRows,\r\n        depth\r\n      }\r\n\r\n      // Create the cells and values\r\n      row.values = {}\r\n      columns.forEach(column => {\r\n        row.values[column.id] = column.accessor\r\n          ? column.accessor(originalRow, i, { subRows, depth, data })\r\n          : undefined\r\n      })\r\n\r\n      return row\r\n    }\r\n\r\n    // Use the resolved data\r\n    return data.map((d, i) => accessRow(d, i))\r\n  }, [data, columns])\r\n\r\n  return {\r\n    ...props,\r\n    rows: accessedRows\r\n  }\r\n}\r\n","const actions = {}\r\n\r\nexport { actions }\r\n\r\nexport const addActions = acts => {\r\n  Object.keys(acts).forEach(key => {\r\n    actions[key] = acts[key]\r\n  })\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport { getBy, getFirstDefined, setBy } from '../utils'\r\nimport { addActions, actions } from '../actions'\r\nimport { defaultState } from './useTableState'\r\n\r\ndefaultState.expanded = {}\r\n\r\naddActions({\r\n  toggleExpanded: '__toggleExpanded__',\r\n  useExpanded: '__useExpanded__'\r\n})\r\n\r\nconst propTypes = {\r\n  expandedKey: PropTypes.string\r\n}\r\n\r\nexport const useExpanded = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useExpanded')\r\n\r\n  const {\r\n    debug,\r\n    columns,\r\n    rows,\r\n    expandedKey = 'expanded',\r\n    hooks,\r\n    state: [{ expanded }, setState]\r\n  } = props\r\n\r\n  const toggleExpandedByPath = (path, set) => {\r\n    return setState(old => {\r\n      const { expanded } = old\r\n      const existing = getBy(expanded, path)\r\n      set = getFirstDefined(set, !existing)\r\n      return {\r\n        ...old,\r\n        expanded: setBy(expanded, path, set)\r\n      }\r\n    }, actions.toggleExpanded)\r\n  }\r\n\r\n  hooks.row.push(row => {\r\n    const { path } = row\r\n    row.toggleExpanded = set => toggleExpandedByPath(path, set)\r\n  })\r\n\r\n  const expandedRows = useMemo(() => {\r\n    if (debug) console.info('getExpandedRows')\r\n\r\n    const expandedRows = []\r\n\r\n    // Here we do some mutation, but it's the last stage in the\r\n    // immutable process so this is safe\r\n    const handleRow = (row, index, depth = 0, parentPath = []) => {\r\n      // Compute some final state for the row\r\n      const path = [...parentPath, index]\r\n\r\n      row.path = path\r\n      row.depth = depth\r\n\r\n      row.isExpanded =\r\n        (row.original && row.original[expandedKey]) || getBy(expanded, path)\r\n\r\n      row.cells = columns.map(column => {\r\n        const cell = {\r\n          column,\r\n          row,\r\n          state: null,\r\n          value: row.values[column.id]\r\n        }\r\n\r\n        return cell\r\n      })\r\n\r\n      expandedRows.push(row)\r\n\r\n      if (row.isExpanded && row.subRows && row.subRows.length) {\r\n        row.subRows.forEach((row, i) => handleRow(row, i, depth + 1, path))\r\n      }\r\n    }\r\n\r\n    rows.forEach((row, i) => handleRow(row, i))\r\n\r\n    return expandedRows\r\n  }, [rows, expanded, columns])\r\n\r\n  const expandedDepth = findExpandedDepth(expanded)\r\n\r\n  return {\r\n    ...props,\r\n    toggleExpandedByPath,\r\n    expandedDepth,\r\n    rows: expandedRows\r\n  }\r\n}\r\n\r\nfunction findExpandedDepth(obj, depth = 1) {\r\n  return Object.values(obj).reduce((prev, curr) => {\r\n    if (typeof curr === 'object') {\r\n      return Math.max(prev, findExpandedDepth(curr, depth + 1))\r\n    }\r\n    return depth\r\n  }, 0)\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport { defaultFilterFn, getFirstDefined } from '../utils'\r\nimport { addActions, actions } from '../actions'\r\nimport { defaultState } from './useTableState'\r\n\r\ndefaultState.filters = {}\r\naddActions({\r\n  setFilter: '__setFilter__',\r\n  setAllFilters: '__setAllFilters__'\r\n})\r\n\r\nconst propTypes = {\r\n  // General\r\n  columns: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      filterFn: PropTypes.func,\r\n      filterAll: PropTypes.bool,\r\n      canFilter: PropTypes.bool,\r\n      Filter: PropTypes.any\r\n    })\r\n  ),\r\n\r\n  filterFn: PropTypes.func,\r\n  manualFilters: PropTypes.bool\r\n}\r\n\r\nexport const useFilters = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFilters')\r\n\r\n  const {\r\n    debug,\r\n    rows,\r\n    columns,\r\n    filterFn = defaultFilterFn,\r\n    manualFilters,\r\n    disableFilters,\r\n    hooks,\r\n    state: [{ filters }, setState]\r\n  } = props\r\n\r\n  columns.forEach(column => {\r\n    const { id, accessor, canFilter } = column\r\n    column.canFilter = accessor\r\n      ? getFirstDefined(\r\n        canFilter,\r\n        disableFilters === true ? false : undefined,\r\n        true\r\n      )\r\n      : false\r\n    // Was going to add this to the filter hook\r\n    column.filterValue = filters[id]\r\n  })\r\n\r\n  const setFilter = (id, val) => {\r\n    return setState(old => {\r\n      if (typeof val === 'undefined') {\r\n        const { [id]: prev, ...rest } = filters\r\n        return {\r\n          ...old,\r\n          filters: {\r\n            ...rest\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...old,\r\n        filters: {\r\n          ...filters,\r\n          [id]: val\r\n        }\r\n      }\r\n    }, actions.setFilter)\r\n  }\r\n\r\n  const setAllFilters = filters => {\r\n    return setState(old => {\r\n      return {\r\n        ...old,\r\n        filters\r\n      }\r\n    }, actions.setAllFilters)\r\n  }\r\n\r\n  hooks.columns.push(columns => {\r\n    columns.forEach(column => {\r\n      if (column.canFilter) {\r\n        column.setFilter = val => setFilter(column.id, val)\r\n      }\r\n    })\r\n    return columns\r\n  })\r\n\r\n  const filteredRows = useMemo(() => {\r\n    if (manualFilters || !Object.keys(filters).length) {\r\n      return rows\r\n    }\r\n\r\n    if (debug) console.info('getFilteredRows')\r\n\r\n    // Filters top level and nested rows\r\n    const filterRows = rows => {\r\n      let filteredRows = rows\r\n\r\n      filteredRows = Object.entries(filters).reduce(\r\n        (filteredSoFar, [columnID, filterValue]) => {\r\n          // Find the filters column\r\n          const column = columns.find(d => d.id === columnID)\r\n\r\n          // Don't filter hidden columns or columns that have had their filters disabled\r\n          if (!column || column.filterable === false) {\r\n            return filteredSoFar\r\n          }\r\n\r\n          const filterMethod = column.filterMethod || filterFn\r\n\r\n          // If 'filterAll' is set to true, pass the entire dataset to the filter method\r\n          if (column.filterAll) {\r\n            return filterMethod(filteredSoFar, columnID, filterValue, column)\r\n          }\r\n          return filteredSoFar.filter(row =>\r\n            filterMethod(row, columnID, filterValue, column)\r\n          )\r\n        },\r\n        rows\r\n      )\r\n\r\n      // Apply the filter to any subRows\r\n      filteredRows = filteredRows.map(row => {\r\n        if (!row.subRows) {\r\n          return row\r\n        }\r\n        return {\r\n          ...row,\r\n          subRows: filterRows(row.subRows)\r\n        }\r\n      })\r\n\r\n      // then filter any rows without subcolumns because it would be strange to show\r\n      filteredRows = filteredRows.filter(row => {\r\n        if (!row.subRows) {\r\n          return true\r\n        }\r\n        return row.subRows.length > 0\r\n      })\r\n\r\n      return filteredRows\r\n    }\r\n\r\n    return filterRows(rows)\r\n  }, [rows, filters, manualFilters])\r\n\r\n  return {\r\n    ...props,\r\n    setFilter,\r\n    setAllFilters,\r\n    rows: filteredRows\r\n  }\r\n}\r\n","export function sum(values, rows) {\r\n  return values.reduce((sum, next) => sum + next, 0)\r\n}\r\n\r\nexport function average(values, rows) {\r\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport * as aggregations from '../aggregations'\r\nimport { addActions, actions } from '../actions'\r\nimport { defaultState } from './useTableState'\r\nimport {\r\n  mergeProps,\r\n  applyPropHooks,\r\n  defaultGroupByFn,\r\n  getFirstDefined\r\n} from '../utils'\r\n\r\ndefaultState.groupBy = []\r\n\r\naddActions({\r\n  toggleGroupBy: '__toggleGroupBy__'\r\n})\r\n\r\nconst propTypes = {\r\n  // General\r\n  columns: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      aggregate: PropTypes.func,\r\n      canGroupBy: PropTypes.bool,\r\n      Aggregated: PropTypes.any\r\n    })\r\n  ),\r\n  groupByFn: PropTypes.func,\r\n  manualGrouping: PropTypes.bool,\r\n  aggregations: PropTypes.object\r\n}\r\n\r\nexport const useGroupBy = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useGroupBy')\r\n\r\n  const {\r\n    debug,\r\n    rows,\r\n    columns,\r\n    groupByFn = defaultGroupByFn,\r\n    manualGroupBy,\r\n    disableGrouping,\r\n    aggregations: userAggregations = {},\r\n    hooks,\r\n    state: [{ groupBy }, setState]\r\n  } = props\r\n\r\n  columns.forEach(column => {\r\n    const { id, accessor, canGroupBy } = column\r\n    column.grouped = groupBy.includes(id)\r\n\r\n    column.canGroupBy = accessor\r\n      ? getFirstDefined(\r\n        canGroupBy,\r\n        disableGrouping === true ? false : undefined,\r\n        true\r\n      )\r\n      : false\r\n\r\n    column.Aggregated = column.Aggregated || column.Cell\r\n  })\r\n\r\n  const toggleGroupBy = (id, toggle) => {\r\n    return setState(old => {\r\n      const resolvedToggle =\r\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\r\n      if (resolvedToggle) {\r\n        return {\r\n          ...old,\r\n          groupBy: [...groupBy, id]\r\n        }\r\n      }\r\n      return {\r\n        ...old,\r\n        groupBy: groupBy.filter(d => d !== id)\r\n      }\r\n    }, actions.toggleGroupBy)\r\n  }\r\n\r\n  hooks.columns.push(columns => {\r\n    columns.forEach(column => {\r\n      if (column.canGroupBy) {\r\n        column.toggleGroupBy = () => toggleGroupBy(column.id)\r\n      }\r\n    })\r\n    return columns\r\n  })\r\n\r\n  hooks.getGroupByToggleProps = []\r\n\r\n  const addGroupByToggleProps = (columns, api) => {\r\n    columns.forEach(column => {\r\n      const { canGroupBy } = column\r\n      column.getGroupByToggleProps = props => {\r\n        return mergeProps(\r\n          {\r\n            onClick: canGroupBy\r\n              ? e => {\r\n                e.persist()\r\n                column.toggleGroupBy()\r\n              }\r\n              : undefined,\r\n            style: {\r\n              cursor: canGroupBy ? 'pointer' : undefined\r\n            },\r\n            title: 'Toggle GroupBy'\r\n          },\r\n          applyPropHooks(api.hooks.getGroupByToggleProps, column, api),\r\n          props\r\n        )\r\n      }\r\n    })\r\n    return columns\r\n  }\r\n\r\n  hooks.columns.push(addGroupByToggleProps)\r\n  hooks.headers.push(addGroupByToggleProps)\r\n\r\n  const groupedRows = useMemo(() => {\r\n    if (manualGroupBy || !groupBy.length) {\r\n      return rows\r\n    }\r\n    if (debug) console.info('getGroupedRows')\r\n    // Find the columns that can or are aggregating\r\n\r\n    // Uses each column to aggregate rows into a single value\r\n    const aggregateRowsToValues = rows => {\r\n      const values = {}\r\n      columns.forEach(column => {\r\n        const columnValues = rows.map(d => d.values[column.id])\r\n        let aggregate =\r\n          userAggregations[column.aggregate] ||\r\n          aggregations[column.aggregate] ||\r\n          column.aggregate\r\n        if (typeof aggregate === 'function') {\r\n          values[column.id] = aggregate(columnValues, rows)\r\n        } else if (aggregate) {\r\n          throw new Error(\r\n            `Invalid aggregate \"${aggregate}\" passed to column with ID: \"${\r\n              column.id\r\n            }\"`\r\n          )\r\n        } else {\r\n          values[column.id] = columnValues[0]\r\n        }\r\n      })\r\n      return values\r\n    }\r\n\r\n    // Recursively group the data\r\n    const groupRecursively = (rows, groupBy, depth = 0) => {\r\n      // This is the last level, just return the rows\r\n      if (depth >= groupBy.length) {\r\n        return rows\r\n      }\r\n\r\n      // Group the rows together for this level\r\n      let groupedRows = Object.entries(groupByFn(rows, groupBy[depth])).map(\r\n        ([groupByVal, subRows], index) => {\r\n          // Recurse to sub rows before aggregation\r\n          subRows = groupRecursively(subRows, groupBy, depth + 1)\r\n\r\n          const values = aggregateRowsToValues(subRows)\r\n\r\n          const row = {\r\n            groupByID: groupBy[depth],\r\n            groupByVal,\r\n            values,\r\n            subRows,\r\n            depth,\r\n            index\r\n          }\r\n          return row\r\n        }\r\n      )\r\n\r\n      return groupedRows\r\n    }\r\n\r\n    // Assign the new data\r\n    return groupRecursively(rows, groupBy)\r\n  }, [rows, groupBy, columns, manualGroupBy])\r\n\r\n  return {\r\n    ...props,\r\n    rows: groupedRows\r\n  }\r\n}\r\n","import { useMemo } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\nimport { addActions, actions } from '../actions'\r\nimport { defaultState } from './useTableState'\r\nimport {\r\n  mergeProps,\r\n  applyPropHooks,\r\n  getFirstDefined,\r\n  defaultOrderByFn,\r\n  defaultSortByFn\r\n} from '../utils'\r\n\r\ndefaultState.sortBy = []\r\n\r\naddActions({\r\n  sortByChange: '__sortByChange__'\r\n})\r\n\r\nconst propTypes = {\r\n  // General\r\n  columns: PropTypes.arrayOf(\r\n    PropTypes.shape({\r\n      sortByFn: PropTypes.func,\r\n      efaultSortDesc: PropTypes.bool\r\n    })\r\n  ),\r\n  sortByFn: PropTypes.func,\r\n  manualSorting: PropTypes.bool,\r\n  disableSorting: PropTypes.bool,\r\n  defaultSortDesc: PropTypes.bool,\r\n  disableMultiSort: PropTypes.bool\r\n}\r\n\r\nexport const useSortBy = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useSortBy')\r\n\r\n  const {\r\n    debug,\r\n    rows,\r\n    columns,\r\n    orderByFn = defaultOrderByFn,\r\n    sortByFn = defaultSortByFn,\r\n    manualSorting,\r\n    disableSorting,\r\n    defaultSortDesc,\r\n    hooks,\r\n    state: [{ sortBy }, setState]\r\n  } = props\r\n\r\n  columns.forEach(column => {\r\n    const { accessor, canSortBy } = column\r\n    column.canSortBy = accessor\r\n      ? getFirstDefined(\r\n        canSortBy,\r\n        disableSorting === true ? false : undefined,\r\n        true\r\n      )\r\n      : false\r\n  })\r\n\r\n  // Updates sorting based on a columnID, desc flag and multi flag\r\n  const toggleSortByID = (columnID, desc, multi) => {\r\n    return setState(old => {\r\n      const { sortBy } = old\r\n\r\n      // Find the column for this columnID\r\n      const column = columns.find(d => d.id === columnID)\r\n      const resolvedDefaultSortDesc = getFirstDefined(\r\n        column.defaultSortDesc,\r\n        defaultSortDesc\r\n      )\r\n\r\n      // Find any existing sortBy for this column\r\n      const existingSortBy = sortBy.find(d => d.id === columnID)\r\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\r\n\r\n      let newSortBy = []\r\n\r\n      // What should we do with this filter?\r\n      let action\r\n\r\n      if (!multi) {\r\n        if (sortBy.length <= 1 && existingSortBy) {\r\n          if (existingSortBy.desc) {\r\n            action = 'remove'\r\n          } else {\r\n            action = 'toggle'\r\n          }\r\n        } else {\r\n          action = 'replace'\r\n        }\r\n      } else {\r\n        if (!existingSortBy) {\r\n          action = 'add'\r\n        } else {\r\n          if (hasDescDefined) {\r\n            action = 'set'\r\n          } else {\r\n            action = 'toggle'\r\n          }\r\n        }\r\n      }\r\n\r\n      if (action === 'replace') {\r\n        newSortBy = [\r\n          {\r\n            id: columnID,\r\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\r\n          }\r\n        ]\r\n      } else if (action === 'add') {\r\n        newSortBy = [\r\n          ...sortBy,\r\n          {\r\n            id: columnID,\r\n            desc: hasDescDefined ? desc : resolvedDefaultSortDesc\r\n          }\r\n        ]\r\n      } else if (action === 'set') {\r\n        newSortBy = sortBy.map(d => {\r\n          if (d.id === columnID) {\r\n            return {\r\n              ...d,\r\n              desc\r\n            }\r\n          }\r\n          return d\r\n        })\r\n      } else if (action === 'toggle') {\r\n        newSortBy = sortBy.map(d => {\r\n          if (d.id === columnID) {\r\n            return {\r\n              ...d,\r\n              desc: !existingSortBy.desc\r\n            }\r\n          }\r\n          return d\r\n        })\r\n      } else if (action === 'remove') {\r\n        newSortBy = []\r\n      }\r\n\r\n      return {\r\n        ...old,\r\n        sortBy: newSortBy\r\n      }\r\n    }, actions.sortByChange)\r\n  }\r\n\r\n  hooks.columns.push(columns => {\r\n    columns.forEach(column => {\r\n      if (column.canSortBy) {\r\n        column.toggleSortBy = (desc, multi) =>\r\n          toggleSortByID(column.id, desc, multi)\r\n      }\r\n    })\r\n    return columns\r\n  })\r\n\r\n  hooks.getSortByToggleProps = []\r\n\r\n  const addSortByToggleProps = (columns, api) => {\r\n    columns.forEach(column => {\r\n      const { canSortBy } = column\r\n      column.getSortByToggleProps = props => {\r\n        return mergeProps(\r\n          {\r\n            onClick: canSortBy\r\n              ? e => {\r\n                e.persist()\r\n                column.toggleSortBy(\r\n                  undefined,\r\n                  !api.disableMultiSort && e.shiftKey\r\n                )\r\n              }\r\n              : undefined,\r\n            style: {\r\n              cursor: canSortBy ? 'pointer' : undefined\r\n            },\r\n            title: 'Toggle SortBy'\r\n          },\r\n          applyPropHooks(api.hooks.getSortByToggleProps, column, api),\r\n          props\r\n        )\r\n      }\r\n    })\r\n    return columns\r\n  }\r\n\r\n  hooks.columns.push(addSortByToggleProps)\r\n  hooks.headers.push(addSortByToggleProps)\r\n\r\n  // Mutate columns to reflect sorting state\r\n  columns.forEach(column => {\r\n    const { id } = column\r\n    column.sorted = sortBy.find(d => d.id === id)\r\n    column.sortedIndex = sortBy.findIndex(d => d.id === id)\r\n    column.sortedDesc = column.sorted ? column.sorted.desc : undefined\r\n  })\r\n\r\n  const sortedRows = useMemo(() => {\r\n    if (manualSorting || !sortBy.length) {\r\n      return rows\r\n    }\r\n    if (debug) console.info('getSortedRows')\r\n\r\n    const sortMethodsByColumnID = {}\r\n\r\n    columns\r\n      .filter(col => col.sortMethod)\r\n      .forEach(col => {\r\n        sortMethodsByColumnID[col.id] = col.sortMethod\r\n      })\r\n\r\n    const sortData = rows => {\r\n      // Use the orderByFn to compose multiple sortBy's together.\r\n      // This will also perform a stable sorting using the row index\r\n      // if needed.\r\n      const sortedData = orderByFn(\r\n        rows,\r\n        sortBy.map(sort => {\r\n          // Support custom sorting methods for each column\r\n          const columnSortBy = sortMethodsByColumnID[sort.id]\r\n\r\n          // Return the correct sortFn\r\n          return (a, b) =>\r\n            (columnSortBy || sortByFn)(\r\n              a.values[sort.id],\r\n              b.values[sort.id],\r\n              sort.desc\r\n            )\r\n        }),\r\n        // Map the directions\r\n        sortBy.map(d => !d.desc)\r\n      )\r\n\r\n      // TODO: this should be optimized. Not good to loop again\r\n      sortedData.forEach(row => {\r\n        if (!row.subRows) {\r\n          return\r\n        }\r\n        row.subRows = sortData(row.subRows)\r\n      })\r\n\r\n      return sortedData\r\n    }\r\n\r\n    return sortData(rows)\r\n  }, [rows, columns, sortBy, manualSorting])\r\n\r\n  return {\r\n    ...props,\r\n    rows: sortedRows\r\n  }\r\n}\r\n","import { useMemo, useLayoutEffect, useEffect } from 'react'\r\nimport PropTypes from 'prop-types'\r\n\r\n//\r\nimport { addActions, actions } from '../actions'\r\nimport { defaultState } from './useTableState'\r\n\r\ndefaultState.pageSize = 10\r\ndefaultState.pageIndex = 0\r\n\r\naddActions({\r\n  pageChange: '__pageChange__'\r\n})\r\n\r\nconst propTypes = {\r\n  // General\r\n  manualPagination: PropTypes.bool\r\n}\r\n\r\nexport const usePagination = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'usePagination')\r\n\r\n  const {\r\n    rows,\r\n    manualPagination,\r\n    debug,\r\n    state: [\r\n      {\r\n        pageSize,\r\n        pageIndex,\r\n        pageCount: userPageCount,\r\n        filters,\r\n        groupBy,\r\n        sortBy\r\n      },\r\n      setState\r\n    ]\r\n  } = props\r\n\r\n  useEffect(() => {\r\n    setState(\r\n      old => ({\r\n        ...old,\r\n        pageIndex: 0\r\n      }),\r\n      actions.pageChange\r\n    )\r\n  }, [filters, groupBy, sortBy])\r\n\r\n  const { pages, pageCount } = useMemo(() => {\r\n    if (manualPagination) {\r\n      return {\r\n        pages: [rows],\r\n        pageCount: userPageCount\r\n      }\r\n    }\r\n    if (debug) console.info('getPages')\r\n\r\n    // Create a new pages with the first page ready to go.\r\n    const pages = rows.length ? [] : [[]]\r\n\r\n    // Start the pageIndex and currentPage cursors\r\n    let cursor = 0\r\n    while (cursor < rows.length) {\r\n      const end = cursor + pageSize\r\n      pages.push(rows.slice(cursor, end))\r\n      cursor = end\r\n    }\r\n\r\n    const pageCount = pages.length\r\n\r\n    return {\r\n      pages,\r\n      pageCount,\r\n      pageOptions\r\n    }\r\n  }, [rows, pageSize, userPageCount])\r\n\r\n  const pageOptions = [...new Array(pageCount)].map((d, i) => i)\r\n  const page = manualPagination ? rows : pages[pageIndex] || []\r\n  const canPreviousPage = pageIndex > 0\r\n  const canNextPage = pageIndex < pageCount - 1\r\n\r\n  const gotoPage = pageIndex => {\r\n    if (debug) console.info('gotoPage')\r\n    return setState(old => {\r\n      if (pageIndex < 0 || pageIndex > pageCount - 1) {\r\n        return old\r\n      }\r\n      return {\r\n        ...old,\r\n        pageIndex\r\n      }\r\n    }, actions.pageChange)\r\n  }\r\n\r\n  const previousPage = () => {\r\n    return gotoPage(pageIndex - 1)\r\n  }\r\n\r\n  const nextPage = () => {\r\n    return gotoPage(pageIndex + 1)\r\n  }\r\n\r\n  const setPageSize = pageSize => {\r\n    setState(old => {\r\n      const topRowIndex = old.pageSize * old.pageIndex\r\n      const pageIndex = Math.floor(topRowIndex / pageSize)\r\n      return {\r\n        ...old,\r\n        pageIndex,\r\n        pageSize\r\n      }\r\n    }, actions.setPageSize)\r\n  }\r\n\r\n  return {\r\n    ...props,\r\n    pages,\r\n    pageOptions,\r\n    page,\r\n    canPreviousPage,\r\n    canNextPage,\r\n    gotoPage,\r\n    previousPage,\r\n    nextPage,\r\n    setPageSize\r\n  }\r\n}\r\n","import PropTypes from 'prop-types'\r\n\r\nimport { getFirstDefined, sum } from '../utils'\r\n\r\nexport const actions = {}\r\n\r\nconst propTypes = {\r\n  defaultFlex: PropTypes.number\r\n}\r\n\r\nexport const useFlexLayout = props => {\r\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useFlexLayout')\r\n\r\n  const {\r\n    defaultFlex = 1,\r\n    hooks: {\r\n      columns: columnsHooks,\r\n      getRowProps,\r\n      getHeaderRowProps,\r\n      getHeaderProps,\r\n      getCellProps\r\n    }\r\n  } = props\r\n\r\n  columnsHooks.push((columns, api) => {\r\n    const visibleColumns = columns.filter(column => {\r\n      column.visible =\r\n        typeof column.show === 'function' ? column.show(api) : !!column.show\r\n      return column.visible\r\n    })\r\n\r\n    const columnMeasurements = {}\r\n\r\n    let sumWidth = 0\r\n    visibleColumns.forEach(column => {\r\n      const { width, minWidth } = getSizesForColumn(\r\n        column,\r\n        defaultFlex,\r\n        undefined,\r\n        undefined,\r\n        api\r\n      )\r\n      if (width) {\r\n        sumWidth += width\r\n      } else if (minWidth) {\r\n        sumWidth += minWidth\r\n      } else {\r\n        sumWidth += defaultFlex\r\n      }\r\n    })\r\n\r\n    const rowStyles = {\r\n      style: {\r\n        display: 'flex',\r\n        minWidth: `${sumWidth}px`\r\n      }\r\n    }\r\n\r\n    api.rowStyles = rowStyles\r\n\r\n    getRowProps.push(() => rowStyles)\r\n    getHeaderRowProps.push(() => rowStyles)\r\n\r\n    getHeaderProps.push(column => ({\r\n      style: {\r\n        boxSizing: 'border-box',\r\n        ...getStylesForColumn(column, columnMeasurements, defaultFlex, api)\r\n      }\r\n      // [refKey]: el => {\r\n      //   renderedCellInfoRef.current[key] = {\r\n      //     column,\r\n      //     el\r\n      //   };\r\n      // },\r\n    }))\r\n\r\n    getCellProps.push(cell => {\r\n      return {\r\n        style: {\r\n          display: 'block',\r\n          boxSizing: 'border-box',\r\n          ...getStylesForColumn(\r\n            cell.column,\r\n            columnMeasurements,\r\n            defaultFlex,\r\n            undefined,\r\n            api\r\n          )\r\n        }\r\n        // [refKey]: el => {\r\n        //   renderedCellInfoRef.current[columnPathStr] = {\r\n        //     column,\r\n        //     el\r\n        //   };\r\n        // }\r\n      }\r\n    })\r\n\r\n    return columns\r\n  })\r\n\r\n  return props\r\n}\r\n\r\n// Utils\r\n\r\nfunction getStylesForColumn(column, columnMeasurements, defaultFlex, api) {\r\n  const { flex, width, maxWidth } = getSizesForColumn(\r\n    column,\r\n    columnMeasurements,\r\n    defaultFlex,\r\n    api\r\n  )\r\n\r\n  return {\r\n    flex: `${flex} 0 auto`,\r\n    width: `${width}px`,\r\n    maxWidth: `${maxWidth}px`\r\n  }\r\n}\r\n\r\nfunction getSizesForColumn(\r\n  { columns, id, width, minWidth, maxWidth },\r\n  columnMeasurements,\r\n  defaultFlex,\r\n  api\r\n) {\r\n  if (columns) {\r\n    columns = columns\r\n      .map(column =>\r\n        getSizesForColumn(column, columnMeasurements, defaultFlex, api)\r\n      )\r\n      .filter(Boolean)\r\n\r\n    if (!columns.length) {\r\n      return false\r\n    }\r\n\r\n    const flex = sum(columns.map(col => col.flex))\r\n    const width = sum(columns.map(col => col.width))\r\n    const maxWidth = sum(columns.map(col => col.maxWidth))\r\n\r\n    return {\r\n      flex,\r\n      width,\r\n      maxWidth\r\n    }\r\n  }\r\n\r\n  return {\r\n    flex: width ? 0 : defaultFlex,\r\n    width:\r\n      width === 'auto'\r\n        ? columnMeasurements[id] || defaultFlex\r\n        : getFirstDefined(width, minWidth, defaultFlex),\r\n    maxWidth\r\n  }\r\n}\r\n\r\n// const resetRefs = () => {\r\n//   if (debug) console.info(\"resetRefs\");\r\n//   renderedCellInfoRef.current = {};\r\n// };\r\n\r\n// const calculateAutoWidths = () => {\r\n//   RAF(() => {\r\n//     const newColumnMeasurements = {};\r\n//     Object.values(renderedCellInfoRef.current).forEach(({ column, el }) => {\r\n//       if (!el) {\r\n//         return;\r\n//       }\r\n\r\n//       let measurement = 0;\r\n\r\n//       const measureChildren = children => {\r\n//         if (children) {\r\n//           [].slice.call(children).forEach(child => {\r\n//             measurement = Math.max(\r\n//               measurement,\r\n//               Math.ceil(child.offsetWidth) || 0\r\n//             );\r\n//             measureChildren(child.children);\r\n//           });\r\n//         }\r\n//         return measurement;\r\n//       };\r\n\r\n//       const parentDims = getElementDimensions(el);\r\n//       measureChildren(el.children);\r\n\r\n//       newColumnMeasurements[column.id] = Math.max(\r\n//         newColumnMeasurements[column.id] || 0,\r\n//         measurement + parentDims.paddingLeft + parentDims.paddingRight\r\n//       );\r\n//     });\r\n\r\n//     const oldKeys = Object.keys(columnMeasurements);\r\n//     const newKeys = Object.keys(newColumnMeasurements);\r\n\r\n//     const needsUpdate =\r\n//       oldKeys.length !== newKeys.length ||\r\n//       oldKeys.some(key => {\r\n//         return columnMeasurements[key] !== newColumnMeasurements[key];\r\n//       });\r\n\r\n//     if (needsUpdate) {\r\n//       setState(old => {\r\n//         return {\r\n//           ...old,\r\n//           columnMeasurements: newColumnMeasurements\r\n//         };\r\n//       }, actions.updateAutoWidth);\r\n//     }\r\n//   });\r\n// };\r\n","import { useState } from 'react'\r\n\r\n// Token pagination behaves a bit differently from\r\n// index based pagination. This hook aids in that process.\r\n\r\nexport const useTokenPagination = () => {\r\n  const [pageToken, setPageToken] = useState()\r\n  const [nextPageToken, setNextPageToken] = useState()\r\n  const [previousPageTokens, setPreviousPageTokens] = useState([])\r\n  const [pageIndex, setPageIndex] = useState(0)\r\n\r\n  // Since we're using pagination tokens intead of index, we need\r\n  // to be a bit clever with page-like navigation here.\r\n  const nextPage = () => {\r\n    setPageIndex(old => old + 1)\r\n    setPreviousPageTokens(old => [...old, pageToken])\r\n    setPageToken(nextPageToken)\r\n  }\r\n\r\n  const previousPage = () => {\r\n    setPageIndex(old => old - 1)\r\n    setPreviousPageTokens(old =>\r\n      [...old]\r\n        .reverse()\r\n        .slice(1)\r\n        .reverse()\r\n    )\r\n    setPageToken(previousPageTokens[previousPageTokens.length - 1])\r\n  }\r\n\r\n  const resetPagination = () => {\r\n    setPageToken(undefined)\r\n    setPageIndex(0)\r\n    setNextPageToken(undefined)\r\n    setPreviousPageTokens([])\r\n  }\r\n\r\n  const canPreviousPage = previousPageTokens.length\r\n  const canNextPage = nextPageToken\r\n\r\n  return {\r\n    setNextPageToken,\r\n    pageToken,\r\n    pageIndex,\r\n    previousPage,\r\n    nextPage,\r\n    canPreviousPage,\r\n    canNextPage,\r\n    resetPagination\r\n  }\r\n}\r\n"],"names":["getBy","obj","path","def","val","pathObj","makePathArray","reduce","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","length","sortFn","desc","sortInt","index","defaultSortByFn","a","b","toLowerCase","getFirstDefined","arguments","defaultGroupByFn","rows","grouper","prev","row","resKey","values","Array","isArray","push","defaultFilterFn","id","value","column","undefined","String","includes","setBy","recurse","depth","key","target","_typeof","flexRender","Comp","props","Object","getPrototypeOf","isReactComponent","React","mergeProps","groups","forEach","style","className","rest","filter","Boolean","join","applyHooks","hooks","initial","args","next","applyPropHooks","sum","curr","flattenDeep","replace","split","newArr","defaultState","defaultReducer","old","newState","useTableState","initialState","overrides","reducer","useState","state","setState","useMemo","keys","updater","type","renderErr","propTypes","data","PropTypes","array","isRequired","debug","bool","useTable","checkPropTypes","userState","process","env","NODE_ENV","api","beforeRender","columns","headers","headerGroups","renderableRows","getTableProps","getRowProps","getHeaderRowProps","getHeaderProps","getCellProps","console","time","plugins","timeEnd","render","userProps","Error","headerGroup","header","visible","prepareRow","cells","cell","columnPathStr","arrayOf","shape","Cell","any","Header","useColumns","userColumns","groupBy","info","columnTree","decorateColumnTree","parent","map","decorateColumn","flattenBy","maxDepth","removeChildColumns","buildGroup","parentColumns","hasParents","some","col","isFirst","latestParentColumn","reverse","originalID","placeholderColumn","makeHeaderGroups","g","find","findMaxDepth","Math","max","accessor","accessorString","error","show","childKey","flatColumns","d","subRowsKey","string","useRows","accessRow","originalRow","original","subRows","actions","addActions","acts","expanded","toggleExpanded","useExpanded","expandedKey","toggleExpandedByPath","set","existing","expandedRows","handleRow","parentPath","isExpanded","expandedDepth","findExpandedDepth","filters","setFilter","setAllFilters","filterFn","func","filterAll","canFilter","Filter","manualFilters","useFilters","disableFilters","filterValue","filteredRows","filterRows","entries","filteredSoFar","columnID","filterable","filterMethod","average","round","toggleGroupBy","aggregate","canGroupBy","Aggregated","groupByFn","manualGrouping","aggregations","object","useGroupBy","manualGroupBy","disableGrouping","userAggregations","grouped","toggle","getGroupByToggleProps","addGroupByToggleProps","onClick","persist","title","groupRecursively","groupByVal","columnValues","groupByID","sortBy","sortByChange","sortByFn","efaultSortDesc","manualSorting","disableSorting","defaultSortDesc","disableMultiSort","useSortBy","orderByFn","canSortBy","toggleSortBy","multi","action","resolvedDefaultSortDesc","existingSortBy","hasDescDefined","newSortBy","getSortByToggleProps","addSortByToggleProps","shiftKey","sorted","sortedIndex","findIndex","sortedDesc","sortMethodsByColumnID","sortMethod","sortData","sortedData","columnSortBy","pageSize","pageIndex","pageChange","manualPagination","usePagination","userPageCount","pageCount","useEffect","pages","end","slice","pageOptions","page","gotoPage","canPreviousPage","canNextPage","previousPage","nextPage","setPageSize","topRowIndex","floor","defaultFlex","number","useFlexLayout","columnsHooks","visibleColumns","columnMeasurements","sumWidth","getSizesForColumn","width","minWidth","rowStyles","display","boxSizing","getStylesForColumn","flex","maxWidth","useTokenPagination","pageToken","setPageToken","nextPageToken","setNextPageToken","previousPageTokens","setPreviousPageTokens","setPageIndex","resetPagination"],"mappings":"mvFAEO,SAASA,MAAMC,EAAKC,EAAMC,OAC1BD,SACID,MAGLG,EADEC,EAAUC,cAAcJ,OAG5BE,EAAMC,EAAQE,OAAO,SAACC,EAAQC,UAAaD,EAAOC,IAAWR,GAC7D,MAAOS,gBAGa,IAARN,EAAsBA,EAAMD,EAG5C,SAAgBQ,iBAAiBC,EAAKC,EAAOC,UACpCC,mBAAIH,GAAKI,KAAK,SAACC,EAAMC,OACrB,IAAIC,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,GAAK,EAAG,KAClCE,EAASR,EAAMM,GACfG,GAAmB,IAAZR,EAAKK,IAA4B,SAAZL,EAAKK,GACjCI,EAAUF,EAAOJ,EAAMC,MACb,IAAZK,SACKD,GAAQC,EAAUA,SAGtBT,EAAK,GAAKG,EAAKO,MAAQN,EAAKM,MAAQN,EAAKM,MAAQP,EAAKO,QAIjE,SAAgBC,gBAAgBC,EAAGC,EAAGL,UAGpCK,EAAIA,MAAAA,EAAgC,GAAKA,EAEzCD,EAAiB,iBAHjBA,EAAIA,MAAAA,EAAgC,GAAKA,GAGbA,EAAEE,cAAgBF,GAC9CC,EAAiB,iBAANA,EAAiBA,EAAEC,cAAgBD,GAE1CD,EACK,EAELA,EAAIC,GACE,EAIH,EAGT,SAAgBE,sBACT,IAAIV,EAAI,EAAGA,EAAIW,UAAKV,OAAQD,GAAK,UACb,KAAPA,uBAAAA,mBAAAA,WACFA,uBAAAA,mBAAAA,GAKX,SAASY,iBAAiBC,EAAMC,UAC9BD,EAAKzB,OAAO,SAAC2B,EAAMC,EAAKhB,OACvBiB,EACe,mBAAZH,EACHA,EAAQE,EAAIE,OAAQlB,GACpBgB,EAAIE,OAAOJ,UACjBC,EAAKE,GAAUE,MAAMC,QAAQL,EAAKE,IAAWF,EAAKE,GAAU,GAC5DF,EAAKE,GAAQI,KAAKL,GACXD,GACN,IAGL,SAAgBO,gBAAgBN,EAAKO,EAAIC,EAAOC,eACpBC,IAAnBV,EAAIE,OAAOK,IACdI,OAAOX,EAAIE,OAAOK,IACjBd,cACAmB,SAASD,OAAOH,GAAOf,eAI9B,SAAgBoB,YAAM/C,yDAAM,GAAIC,yCAAMyC,gDACpB,SAAVM,EAAWhD,OAAKiD,yDAAQ,EACtBC,EAAMjD,EAAKgD,GACXE,EAA6B,WAApBC,QAAOpD,EAAIkD,IAAoB,GAAKlD,EAAIkD,2BAIlDlD,qBACFkD,EAHDD,IAAUhD,EAAKkB,OAAS,EAAIuB,EAAQM,EAAQG,EAAQF,EAAQ,KAOzDD,CAAQhD,GA4BV,SAASqD,WAAWC,EAAMC,SACX,mBAATD,EACFE,OAAOC,eAAeH,GAAMI,iBACjCC,6BAACL,EAASC,GAEVD,EAAKC,GAGFD,EAGF,IAAMM,WAAa,mBACpBL,EAAQ,sBADgBM,2BAAAA,yBAE5BA,EAAOC,QAAQ,wEAAsC,OAAnCC,MAAAA,aAAQ,KAAIC,IAAAA,UAAcC,oDAC1CV,mBACKA,EACAU,GACHF,uBACMR,EAAMQ,OAAS,GAChBA,GAELC,UAAW,CAACT,EAAMS,UAAWA,GAAWE,OAAOC,SAASC,KAAK,SAG1Db,GAGIc,WAAa,SAACC,EAAOC,8BAAYC,mCAAAA,2BAC5CF,EAAMhE,OAAO,SAAC2B,EAAMwC,UAASA,gBAAKxC,UAASuC,KAAOD,IAEvCG,eAAiB,SAACJ,8BAAUE,mCAAAA,2BACvCF,EAAMhE,OAAO,SAAC2B,EAAMwC,UAASb,WAAW3B,EAAMwC,eAAQD,KAAQ,KAYzD,SAASG,IAAIhE,UACXA,EAAIL,OAAO,SAAC2B,EAAM2C,UAAS3C,EAAO2C,GAAM,GAGjD,SAASvE,cAAcL,UACd6E,YAAY7E,GAChBoE,KAAK,KACLU,QAAQ,MAAO,KACfA,QAAQ,MAAO,IACfC,MAAM,KAGX,SAASF,YAAYlE,OAAKqE,yDAAS,MAC5B3C,MAAMC,QAAQ3B,OAGZ,IAAIO,EAAI,EAAGA,EAAIP,EAAIQ,OAAQD,GAAK,EACnC2D,YAAYlE,EAAIO,GAAI8D,QAHtBA,EAAOzC,KAAK5B,UAMPqE,EClLF,IAAMC,aAAe,GAEtBC,eAAiB,SAACC,EAAKC,UAAaA,GAE7BC,cAAgB,eAC3BC,yDAAe,GACfC,yDAAY,4DACsD,OAAhEC,QAAAA,aAAUN,qBAAgBO,sCAAyBA,mCAGhDR,aACAK,OAFAI,OAAOC,aAqBL,CAhBiBC,cAAQ,eACxBR,mBACDM,UAELlC,OAAOqC,KAAKN,GAAWzB,QAAQ,SAAAZ,GAC7BkC,EAASlC,GAAOqC,EAAUrC,KAErBkC,IACLM,6BAAUlC,OAAOpB,OAAOmD,MAEJ,SAACO,EAASC,UAChCJ,EAAS,SAAAR,OACDC,EAAWU,EAAQX,UAClBK,EAAQL,EAAKC,EAAUW,QCvB9BC,UACJ,iIAEIC,UAAY,CAEhBC,KAAMC,UAAUC,MAAMC,WACtBC,MAAOH,UAAUI,MAGNC,SAAW,SAACjD,GAEvB4C,UAAUM,eAAeR,UAAW1C,EAAO,WAAY,kBAGVA,EAAvC2C,KAAAA,aAAO,KAAWQ,EAAqBnD,EAA5BmC,MAAkBY,EAAU/C,EAAV+C,MAEnCA,EAAiC,eAAzBK,QAAQC,IAAIC,UAAoCP,MAGlDrB,EAAeI,gBAsBjByB,mBACCvD,GACH2C,KAAAA,EACAR,MAtBYgB,GAAazB,EAuBzBX,MApBY,CACZyC,aAAc,GACdC,QAAS,GACTC,QAAS,GACTC,aAAc,GACdnF,KAAM,GACNG,IAAK,GACLiF,eAAgB,GAChBC,cAAe,GACfC,YAAa,GACbC,kBAAmB,GACnBC,eAAgB,GAChBC,aAAc,MAWZlB,GAAOmB,QAAQC,KAAK,oCAvCSC,mCAAAA,2BAyCjCb,EAAMa,EAAQzD,OAAOC,SAAS7D,OAAO,SAAC2B,EAAMwC,UAASA,EAAKxC,IAAO6E,GAC7DR,GAAOmB,QAAQG,QAAQ,SAGvBtB,GAAOmB,QAAQC,KAAK,sBACxBrD,WAAWyC,EAAIxC,MAAMyC,kBAAcnE,EAAWkE,GAC1CR,GAAOmB,QAAQG,QAAQ,sBAEvBtB,GAAOmB,QAAQC,KAAK,iBACxBZ,EAAIE,QAAU3C,WAAWyC,EAAIxC,MAAM0C,QAASF,EAAIE,QAASF,GACrDR,GAAOmB,QAAQG,QAAQ,iBAEvBtB,GAAOmB,QAAQC,KAAK,iBACxBZ,EAAIG,QAAU5C,WAAWyC,EAAIxC,MAAM2C,QAASH,EAAIG,QAASH,GACrDR,GAAOmB,QAAQG,QAAQ,8CACtBd,EAAIE,4BAAYF,EAAIG,UAASnD,QAAQ,SAAAnB,GAExCA,EAAOkF,OAAS,SAAC9B,OAAM+B,yDAAY,OAC5B/B,QACG,IAAIgC,MAAM/B,kBAEX3C,WAAWV,EAAOoD,oBACpBe,EACAnE,EACAmF,KAKPnF,EAAO4E,eAAiB,SAAAhE,UACtBK,WACE,CACEV,IAAK,CAAC,SAAUP,EAAOF,IAAI2B,KAAK,MAElCM,eAAeoC,EAAIxC,MAAMiD,eAAgB5E,EAAQmE,GACjDvD,MAIF+C,GAAOmB,QAAQC,KAAK,sBACxBZ,EAAII,aAAe7C,WACjByC,EAAIxC,MAAM4C,aACVJ,EAAII,aACJJ,GACA5C,OAAO,SAAC8D,EAAa9G,UAErB8G,EAAYf,QAAUe,EAAYf,QAAQ/C,OAAO,SAAA+D,UAQ3CA,EAAOjB,QAPK,SAAVhE,EAAUgE,UACdA,EAAQ9C,OAAO,SAAAvB,UACTA,EAAOqE,QACFhE,EAAQL,EAAOqE,SAEjBrE,EAAOuF,UACb/G,OAEI6B,CAAQiF,EAAOjB,SAEjBiB,EAAOC,YAIZF,EAAYf,QAAQ9F,SACtB6G,EAAYX,YAAc,eAAC9D,yDAAQ,UACjCK,WACE,CACEV,IAAK,iBAAUhC,IAAKkD,KAAK,MAE3BM,eAAeoC,EAAIxC,MAAMgD,kBAAmBU,EAAalB,GACzDvD,KAEG,KAKP+C,GAAOmB,QAAQG,QAAQ,sBAGvBtB,GAAOmB,QAAQC,KAAK,cACxBZ,EAAI/E,KAAOsC,WAAWyC,EAAIxC,MAAMvC,KAAM+E,EAAI/E,KAAM+E,GAC5CR,GAAOmB,QAAQG,QAAQ,cAI3Bd,EAAIqB,WAAa,SAAAjG,OACPjC,EAASiC,EAATjC,KACRiC,EAAImF,YAAc,SAAA9D,UAChBK,WACE,CAAEV,IAAK,CAAC,MAAOjD,GAAMmE,KAAK,MAC1BC,WAAWyC,EAAIxC,MAAM+C,YAAanF,EAAK4E,GACvCvD,IAIJc,WAAWyC,EAAIxC,MAAMpC,IAAKA,EAAK4E,GAE/B5E,EAAIkG,MAAQlG,EAAIkG,MAAMlE,OAAO,SAAAmE,UAAQA,EAAK1F,OAAOuF,UAEjDhG,EAAIkG,MAAMtE,QAAQ,SAAAuE,MACXA,OAIG1F,EAAW0F,EAAX1F,OAER0F,EAAKb,aAAe,SAAAjE,OACZ+E,EAAgB,CAACrI,EAAM0C,EAAOF,IAAI2B,KAAK,YACtCR,WACL,CACEV,IAAK,CAAC,OAAQoF,GAAelE,KAAK,MAEpCM,eAAeoC,EAAIxC,MAAMkD,aAAca,EAAMvB,GAC7CvD,IAKJ8E,EAAKR,OAAS,SAAC9B,OAAM+B,yDAAY,OAC1B/B,QACG,IAAIgC,MACR,8JAGG1E,WAAWV,EAAOoD,oBACpBe,EACAuB,EACAP,SAMXhB,EAAIM,cAAgB,SAAAU,UAClBlE,WAAWc,eAAeoC,EAAIxC,MAAM8C,cAAeN,GAAMgB,IAE3DhB,EAAIO,YAAc,SAAAS,UAChBlE,WAAWc,eAAeoC,EAAIxC,MAAM+C,YAAaP,GAAMgB,IAElDhB,GC7LHb,YAAY,CAEhBe,QAASb,UAAUoC,QACjBpC,UAAUqC,MAAM,CACdC,KAAMtC,UAAUuC,IAChBC,OAAQxC,UAAUuC,QAKXE,WAAa,SAAArF,OAEtB+C,EAGE/C,EAHF+C,MACSuC,EAEPtF,EAFFyD,QACU8B,iBACRvF,EADFmC,YAAUoD,QAGZ3C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,oBAEZqC,cAAQ,WAC7CU,GAAOmB,QAAQsB,KAAK,kBAGpBC,WAwEGC,EAAmBjC,EAASkC,OAAQjG,yDAAQ,SAC5C+D,EAAQmC,IAAI,SAAAxG,UACjBA,EAASyG,EAAezG,EAAQuG,IACrBlC,UACTrE,EAAOqE,QAAUiC,EAAmBtG,EAAOqE,QAASrE,EAAQM,EAAQ,IAE/DN,IA9EQsG,CAAmBJ,GAGhC7B,EAAUqC,EAAUL,EAAY,WAQ9B9B,WA0FkBF,EAASsC,OAC3BpC,EAAe,GAQrBF,EAAQlD,QANmB,SAArByF,EAAqB5G,UAClBA,EAAOqE,QACVrE,EAAOuG,QACTK,EAAmB5G,EAAOuG,iBAKX,SAAbM,EAAcxC,OAAS/D,yDAAQ,EAC7B+E,EAAc,CAClBf,QAAS,IAGLwC,EAAgB,GAEhBC,EAAa1C,EAAQ2C,KAAK,SAAAC,UAAOA,EAAIV,SAE3ClC,EAAQlD,QAAQ,SAAAnB,OACRkH,GAAWJ,EAActI,OAC3B2I,EAAqB,UAAIL,GAAeM,UAAU,MAGlDpH,EAAOuG,QACLW,GAAWC,EAAmBE,aAAerH,EAAOuG,OAAOzG,KAC7DgH,EAAclH,sBACTI,EAAOuG,QACVc,WAAYrH,EAAOuG,OAAOzG,GAC1BA,GAAI,CAACE,EAAOuG,OAAOzG,GAAIgH,EAActI,QAAQiD,KAAK,aAGjD,GAAIsF,EAAY,KAEfO,EAAoBb,EAAe,CACvCY,WAAY,CAACrH,EAAOF,GAAI,cAAe6G,EAAWrG,GAAOmB,KAAK,KAC9D3B,GAAI,CACFE,EAAOF,GACP,cACA6G,EAAWrG,EACXwG,EAActI,QACdiD,KAAK,QAGPyF,GACAC,EAAmBE,aAAeC,EAAkBD,aAEpDP,EAAclH,KAAK0H,IAKnBtH,EAAOuG,QAAUQ,MACnBI,EAAqB,UAAIL,GAAeM,UAAU,IAC/B/C,QAAU8C,EAAmB9C,SAAW,GACtD8C,EAAmB9C,QAAQlE,SAASH,IACvCmH,EAAmB9C,QAAQzE,KAAKI,IAIpCqF,EAAYf,QAAQ1E,KAAKI,KAG3BuE,EAAa3E,KAAKyF,GAEdyB,EAActI,QAChBqI,EAAWC,GAIfD,CAAWxC,GAEJE,EAAa6C,UAnKCG,CANrBlD,+BACK8B,EAAQK,IAAI,SAAAgB,UAAKnD,EAAQoD,KAAK,SAAAR,UAAOA,EAAInH,KAAO0H,0BAChDnD,EAAQ9C,OAAO,SAAA0F,UAAQd,EAAQhG,SAAS8G,EAAInH,iBAsB1C4H,EAAarD,OAAS/D,yDAAQ,SAC9B+D,EAAQ1G,OAAO,SAAC2B,EAAM2C,UACvBA,EAAKoC,QACAsD,KAAKC,IAAItI,EAAMoI,EAAazF,EAAKoC,QAAS/D,EAAQ,IAEpDA,GACN,GAxB4CoH,CAAarB,IACtD/B,EAAUoC,EAAUnC,EAAc,iBAEjC,CACLF,QAAAA,EACAE,aAAAA,EACAD,QAAAA,IAED,CAAC6B,EAASD,4BAGRtF,GACHyD,UA3BMA,QA4BNE,eA5BeA,aA6BfD,UA7B6BA,mBA0CtBmC,EAAezG,EAAQuG,SAECvG,EAAzBF,IAAAA,GAAI+H,IAAAA,SAAU7B,IAAAA,UAEI,iBAAb6B,EAAuB,CAChC/H,EAAKA,GAAM+H,MACLC,EAAiBD,EACvBA,EAAW,SAAAtI,UAAOnC,MAAMmC,EAAKuI,OAG1BhI,GAAwB,iBAAXkG,IAChBlG,EAAKkG,IAGFlG,QAEHgF,QAAQiD,MAAM/H,GACR,IAAIoF,MAAM,mCAGlBpF,iBACEgG,OAAQ,GACRF,KAAM,SAAAJ,UAAQA,EAAK3F,OACnBiI,MAAM,GACHhI,GACHF,GAAAA,EACA+H,SAAAA,EACAtB,OAAAA,aAiBKG,EAAUrC,EAAS4D,OACpBC,EAAc,UAEJ,SAAV7H,EAAUgE,GACdA,EAAQlD,QAAQ,SAAAgH,GACTA,EAAEF,GAGL5H,EAAQ8H,EAAEF,IAFVC,EAAYtI,KAAKuI,KAOvB9H,CAAQgE,GAED6D,IC1HL5E,YAAY,CAChB8E,WAAY5E,UAAU6E,QAGXC,QAAU,SAAA1H,GACrB4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,eAE/C+C,EAAiD/C,EAAjD+C,MAAOU,EAA0CzD,EAA1CyD,UAA0CzD,EAAjCwH,WAAAA,aAAa,YAAW7E,EAAS3C,EAAT2C,6BAsC3C3C,GACHxB,KArCmB6D,cAAQ,WACvBU,GAAOmB,QAAQsB,KAAK,0BA+BjB7C,EAAKiD,IAAI,SAAC2B,EAAG5J,UA5BF,SAAZgK,EAAaC,EAAajK,OAAG+B,yDAAQ,EAEnCmI,EAAWD,EAGXE,EAAUF,EAAYJ,GACxBI,EAAYJ,GAAY5B,IAAI,SAAC2B,EAAG5J,UAAMgK,EAAUJ,EAAG5J,EAAG+B,EAAQ,UAC9DL,EAEEV,EAAM,CACVkJ,SAAAA,EACA7J,MAAOL,EACPmK,QAAAA,EACApI,MAAAA,EAIFf,OAAa,WACb8E,EAAQlD,QAAQ,SAAAnB,GACdT,EAAIE,OAAOO,EAAOF,IAAME,EAAO6H,SAC3B7H,EAAO6H,SAASW,EAAajK,EAAG,CAAEmK,QAAAA,EAASpI,MAAAA,EAAOiD,KAAAA,SAClDtD,IAGCV,EAIiBgJ,CAAUJ,EAAG5J,MACtC,CAACgF,EAAMc,OC7CNsE,QAAU,GAIHC,WAAa,SAAAC,GACxBhI,OAAOqC,KAAK2F,GAAM1H,QAAQ,SAAAZ,GACxBoI,QAAQpI,GAAOsI,EAAKtI,MCCxB+B,aAAawG,SAAW,GAExBF,WAAW,CACTG,eAAgB,qBAChBC,YAAa,oBAGf,IAAM1F,YAAY,CAChB2F,YAAazF,UAAU6E,QAGZW,YAAc,SAAApI,GACzB4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,mBAGrD+C,EAME/C,EANF+C,MACAU,EAKEzD,EALFyD,QACAjF,EAIEwB,EAJFxB,OAIEwB,EAHFqI,YAAAA,aAAc,aACdtH,EAEEf,EAFFe,uBAEEf,EADFmC,SAAU+F,OAAAA,SAAY9F,OAGlBkG,EAAuB,SAAC5L,EAAM6L,UAC3BnG,EAAS,SAAAR,OACNsG,EAAatG,EAAbsG,SACFM,EAAWhM,MAAM0L,EAAUxL,UACjC6L,EAAMlK,gBAAgBkK,GAAMC,oBAEvB5G,GACHsG,SAAU1I,MAAM0I,EAAUxL,EAAM6L,MAEjCR,QAAQI,iBAGbpH,EAAMpC,IAAIK,KAAK,SAAAL,OACLjC,EAASiC,EAATjC,KACRiC,EAAIwJ,eAAiB,SAAAI,UAAOD,EAAqB5L,EAAM6L,UAGnDE,EAAepG,cAAQ,WACvBU,GAAOmB,QAAQsB,KAAK,uBAElBiD,EAAe,UAgCrBjK,EAAK+B,QAAQ,SAAC5B,EAAKhB,UA5BD,SAAZ+K,EAAa/J,EAAKX,OAAO0B,yDAAQ,EAAGiJ,yDAAa,GAE/CjM,+BAAWiM,IAAY3K,IAE7BW,EAAIjC,KAAOA,EACXiC,EAAIe,MAAQA,EAEZf,EAAIiK,WACDjK,EAAIkJ,UAAYlJ,EAAIkJ,SAASQ,IAAiB7L,MAAM0L,EAAUxL,GAEjEiC,EAAIkG,MAAQpB,EAAQmC,IAAI,SAAAxG,SACT,CACXA,OAAAA,EACAT,IAAAA,EACAwD,MAAO,KACPhD,MAAOR,EAAIE,OAAOO,EAAOF,OAM7BuJ,EAAazJ,KAAKL,GAEdA,EAAIiK,YAAcjK,EAAImJ,SAAWnJ,EAAImJ,QAAQlK,QAC/Ce,EAAImJ,QAAQvH,QAAQ,SAAC5B,EAAKhB,UAAM+K,EAAU/J,EAAKhB,EAAG+B,EAAQ,EAAGhD,KAIxCgM,CAAU/J,EAAKhB,KAEjC8K,GACN,CAACjK,EAAM0J,EAAUzE,IAEdoF,EAAgBC,kBAAkBZ,2BAGnClI,GACHsI,qBAAAA,EACAO,cAAAA,EACArK,KAAMiK,KAIV,SAASK,kBAAkBrM,OAAKiD,yDAAQ,SAC/BO,OAAOpB,OAAOpC,GAAKM,OAAO,SAAC2B,EAAM2C,SAClB,WAAhBxB,QAAOwB,GACF0F,KAAKC,IAAItI,EAAMoK,kBAAkBzH,EAAM3B,EAAQ,IAEjDA,GACN,GChGLgC,aAAaqH,QAAU,GACvBf,WAAW,CACTgB,UAAW,gBACXC,cAAe,sBAGjB,IAAMvG,YAAY,CAEhBe,QAASb,UAAUoC,QACjBpC,UAAUqC,MAAM,CACdiE,SAAUtG,UAAUuG,KACpBC,UAAWxG,UAAUI,KACrBqG,UAAWzG,UAAUI,KACrBsG,OAAQ1G,UAAUuC,OAItB+D,SAAUtG,UAAUuG,KACpBI,cAAe3G,UAAUI,MAGdwG,WAAa,SAAAxJ,GACxB4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,kBAGrD+C,EAQE/C,EARF+C,MACAvE,EAOEwB,EAPFxB,KACAiF,EAMEzD,EANFyD,UAMEzD,EALFkJ,SAAAA,aAAWjK,kBACXsK,EAIEvJ,EAJFuJ,cACAE,EAGEzJ,EAHFyJ,eACA1I,EAEEf,EAFFe,uBAEEf,EADFmC,SAAU4G,OAAAA,QAAW3G,OAGvBqB,EAAQlD,QAAQ,SAAAnB,OACNF,EAA4BE,EAA5BF,GAAI+H,EAAwB7H,EAAxB6H,SAAUoC,EAAcjK,EAAdiK,UACtBjK,EAAOiK,YAAYpC,GACf5I,gBACAgL,GACmB,IAAnBI,QAAkCpK,GAClC,GAIJD,EAAOsK,YAAcX,EAAQ7J,SAGzB8J,EAAY,SAAC9J,EAAItC,UACdwF,EAAS,SAAAR,WACK,IAARhF,0BAWNgF,GACHmH,yBACKA,qBACF7J,EAAKtC,MAbwBmM,EAAvB7J,2BAEJ0C,GACHmH,kDAH8BA,GAAvB7J,4BAgBV6I,QAAQiB,YAYbjI,EAAM0C,QAAQzE,KAAK,SAAAyE,UACjBA,EAAQlD,QAAQ,SAAAnB,GACVA,EAAOiK,YACTjK,EAAO4J,UAAY,SAAApM,UAAOoM,EAAU5J,EAAOF,GAAItC,OAG5C6G,QAGHkG,EAAetH,cAAQ,cACvBkH,IAAkBtJ,OAAOqC,KAAKyG,GAASnL,cAClCY,EAGLuE,GAAOmB,QAAQsB,KAAK,0BAGL,SAAboE,EAAapL,UAGFyB,OAAO4J,QAAQd,GAAShM,OACrC,SAAC+M,+BAAgBC,OAAUL,OAEnBtK,EAASqE,EAAQoD,KAAK,SAAAU,UAAKA,EAAErI,KAAO6K,QAGrC3K,IAAgC,IAAtBA,EAAO4K,kBACbF,MAGHG,EAAe7K,EAAO6K,cAAgBf,SAGxC9J,EAAOgK,UACFa,EAAaH,EAAeC,EAAUL,EAAatK,GAErD0K,EAAcnJ,OAAO,SAAAhC,UAC1BsL,EAAatL,EAAKoL,EAAUL,EAAatK,MAG7CZ,GAI0BoH,IAAI,SAAAjH,UACzBA,EAAImJ,yBAIJnJ,GACHmJ,QAAS8B,EAAWjL,EAAImJ,WAJjBnJ,IASiBgC,OAAO,SAAAhC,UAC5BA,EAAImJ,SAGmB,EAArBnJ,EAAImJ,QAAQlK,SAMhBgM,CAAWpL,IACjB,CAACA,EAAMuK,EAASQ,4BAGdvJ,GACHgJ,UAAAA,EACAC,cAhFoB,SAAAF,UACb3G,EAAS,SAAAR,2BAETA,GACHmH,QAAAA,KAEDhB,QAAQkB,gBA2EXzK,KAAMmL,KC9JH,SAASvI,MAAIvC,EAAQL,UACnBK,EAAO9B,OAAO,SAACqE,EAAKF,UAASE,EAAMF,GAAM,GAG3C,SAASgJ,QAAQrL,EAAQL,UACvBuI,KAAKoD,MAAO/I,MAAIvC,EAAQL,GAAQK,EAAOjB,OAAU,KAAO,gECQjE8D,aAAa6D,QAAU,GAEvByC,WAAW,CACToC,cAAe,sBAGjB,IAAM1H,YAAY,CAEhBe,QAASb,UAAUoC,QACjBpC,UAAUqC,MAAM,CACdoF,UAAWzH,UAAUuG,KACrBmB,WAAY1H,UAAUI,KACtBuH,WAAY3H,UAAUuC,OAG1BqF,UAAW5H,UAAUuG,KACrBsB,eAAgB7H,UAAUI,KAC1B0H,aAAc9H,UAAU+H,QAGbC,WAAa,SAAA5K,GACxB4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,kBAGrD+C,EASE/C,EATF+C,MACAvE,EAQEwB,EARFxB,KACAiF,EAOEzD,EAPFyD,UAOEzD,EANFwK,UAAAA,aAAYjM,mBACZsM,EAKE7K,EALF6K,cACAC,EAIE9K,EAJF8K,kBAIE9K,EAHF0K,aAAcK,aAAmB,KACjChK,EAEEf,EAFFe,uBAEEf,EADFmC,SAAUoD,OAAAA,QAAWnD,OAGvBqB,EAAQlD,QAAQ,SAAAnB,OACNF,EAA6BE,EAA7BF,GAAI+H,EAAyB7H,EAAzB6H,SAAUqD,EAAelL,EAAfkL,WACtBlL,EAAO4L,QAAUzF,EAAQhG,SAASL,GAElCE,EAAOkL,aAAarD,GAChB5I,gBACAiM,GACoB,IAApBQ,QAAmCzL,GACnC,GAIJD,EAAOmL,WAAanL,EAAOmL,YAAcnL,EAAO8F,OAoBlDnE,EAAM0C,QAAQzE,KAAK,SAAAyE,UACjBA,EAAQlD,QAAQ,SAAAnB,GACVA,EAAOkL,aACTlL,EAAOgL,cAAgB,kBApBNlL,EAoB0BE,EAAOF,GAnB/CkD,EAAS,SAAAR,2BAKPA,QAHa,IAAXqJ,EAAyBA,GAAU1F,EAAQhG,SAASL,KAIzDqG,qCAAaA,IAASrG,MAKxBqG,QAASA,EAAQ5E,OAAO,SAAA4G,UAAKA,IAAMrI,OAEpC6I,QAAQqC,eAdS,IAAClL,EAAI+L,MAuBlBxH,IAGT1C,EAAMmK,sBAAwB,OAExBC,EAAwB,SAAC1H,EAASF,UACtCE,EAAQlD,QAAQ,SAAAnB,OACNkL,EAAelL,EAAfkL,WACRlL,EAAO8L,sBAAwB,SAAAlL,UACtBK,WACL,CACE+K,QAASd,EACL,SAAApN,GACAA,EAAEmO,UACFjM,EAAOgL,sBAEP/K,EACJmB,MAAO,CACLxD,OAAQsN,EAAa,eAAYjL,GAEnCiM,MAAO,kBAETnK,eAAeoC,EAAIxC,MAAMmK,sBAAuB9L,EAAQmE,GACxDvD,MAICyD,UAGT1C,EAAM0C,QAAQzE,KAAKmM,GACnBpK,EAAM2C,QAAQ1E,KAAKmM,oBAoEdnL,GACHxB,KAnEkB6D,cAAQ,cACtBwI,IAAkBtF,EAAQ3H,cACrBY,EAELuE,GAAOmB,QAAQsB,KAAK,yBA4BC,SAAnB+F,EAAoB/M,EAAM+G,OAAS7F,yDAAQ,SAE3CA,GAAS6F,EAAQ3H,OACZY,EAISyB,OAAO4J,QAAQW,EAAUhM,EAAM+G,EAAQ7F,KAASkG,IAChE,WAAwB5H,6BAAtBwN,OAAY1D,OAEZA,EAAUyD,EAAiBzD,EAASvC,EAAS7F,EAAQ,OAlC7BlB,EACtBK,EAmCIA,GApCkBL,EAoCasJ,EAnCnCjJ,EAAS,GACf4E,EAAQlD,QAAQ,SAAAnB,OACRqM,EAAejN,EAAKoH,IAAI,SAAA2B,UAAKA,EAAE1I,OAAOO,EAAOF,MAC/CmL,EACFU,EAAiB3L,EAAOiL,YACxBK,aAAatL,EAAOiL,YACpBjL,EAAOiL,aACgB,mBAAdA,EACTxL,EAAOO,EAAOF,IAAMmL,EAAUoB,EAAcjN,OACvC,CAAA,GAAI6L,QACH,IAAI7F,mCACc6F,0CACpBjL,EAAOF,SAIXL,EAAOO,EAAOF,IAAMuM,EAAa,MAG9B5M,SAkBS,CACV6M,UAAWnG,EAAQ7F,GACnB8L,WAAAA,EACA3M,OAAAA,EACAiJ,QAAAA,EACApI,MAAAA,EACA1B,MAAAA,KAUDuN,CAAiB/M,EAAM+G,IAC7B,CAAC/G,EAAM+G,EAAS9B,EAASoH,OCzK9BnJ,aAAaiK,OAAS,GAEtB3D,WAAW,CACT4D,aAAc,qBAGhB,IAAMlJ,YAAY,CAEhBe,QAASb,UAAUoC,QACjBpC,UAAUqC,MAAM,CACd4G,SAAUjJ,UAAUuG,KACpB2C,eAAgBlJ,UAAUI,QAG9B6I,SAAUjJ,UAAUuG,KACpB4C,cAAenJ,UAAUI,KACzBgJ,eAAgBpJ,UAAUI,KAC1BiJ,gBAAiBrJ,UAAUI,KAC3BkJ,iBAAkBtJ,UAAUI,MAGjBmJ,UAAY,SAAAnM,GACvB4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,iBAGrD+C,EAUE/C,EAVF+C,MACAvE,EASEwB,EATFxB,KACAiF,EAQEzD,EARFyD,UAQEzD,EAPFoM,UAAAA,aAAYjP,qBAOV6C,EANF6L,SAAAA,aAAW5N,kBACX8N,EAKE/L,EALF+L,cACAC,EAIEhM,EAJFgM,eACAC,EAGEjM,EAHFiM,gBACAlL,EAEEf,EAFFe,uBAEEf,EADFmC,SAAUwJ,OAAAA,OAAUvJ,OAGtBqB,EAAQlD,QAAQ,SAAAnB,OACN6H,EAAwB7H,EAAxB6H,SAAUoF,EAAcjN,EAAdiN,UAClBjN,EAAOiN,YAAYpF,GACf5I,gBACAgO,GACmB,IAAnBL,QAAkC3M,GAClC,KA8FN0B,EAAM0C,QAAQzE,KAAK,SAAAyE,UACjBA,EAAQlD,QAAQ,SAAAnB,GACVA,EAAOiN,YACTjN,EAAOkN,aAAe,SAACxO,EAAMyO,UA3FXxC,EA4FD3K,EAAOF,GA5FIpB,EA4FAA,EA5FMyO,EA4FAA,EA3F/BnK,EAAS,SAAAR,OAiBV4K,EAhBIb,EAAW/J,EAAX+J,OAIFc,EAA0BpO,gBADjBoF,EAAQoD,KAAK,SAAAU,UAAKA,EAAErI,KAAO6K,IAEjCkC,gBACPA,GAIIS,EAAiBf,EAAO9E,KAAK,SAAAU,UAAKA,EAAErI,KAAO6K,IAC3C4C,EAAiB,MAAO7O,EAE1B8O,EAAY,SA2BD,YAPTJ,EAfDD,EAWEG,EAGCC,EACO,MAEA,SALF,MAXPhB,EAAO/N,QAAU,GAAK8O,EACpBA,EAAe5O,KACR,SAEA,SAGF,WAeX8O,EAAY,CACV,CACE1N,GAAI6K,EACJjM,KAAM6O,EAAiB7O,EAAO2O,IAGd,QAAXD,EACTI,+BACKjB,IACH,CACEzM,GAAI6K,EACJjM,KAAM6O,EAAiB7O,EAAO2O,KAGd,QAAXD,EACTI,EAAYjB,EAAO/F,IAAI,SAAA2B,UACjBA,EAAErI,KAAO6K,mBAENxC,GACHzJ,KAAAA,IAGGyJ,IAEW,WAAXiF,EACTI,EAAYjB,EAAO/F,IAAI,SAAA2B,UACjBA,EAAErI,KAAO6K,mBAENxC,GACHzJ,MAAO4O,EAAe5O,OAGnByJ,IAEW,WAAXiF,IACTI,EAAY,qBAIThL,GACH+J,OAAQiB,KAET7E,QAAQ6D,cArFU,IAAC7B,EAAUjM,EAAMyO,MA+F/B9I,IAGT1C,EAAM8L,qBAAuB,OAEvBC,EAAuB,SAACrJ,EAASF,UACrCE,EAAQlD,QAAQ,SAAAnB,OACNiN,EAAcjN,EAAdiN,UACRjN,EAAOyN,qBAAuB,SAAA7M,UACrBK,WACL,CACE+K,QAASiB,EACL,SAAAnP,GACAA,EAAEmO,UACFjM,EAAOkN,kBACLjN,GACCkE,EAAI2I,kBAAoBhP,EAAE6P,gBAG7B1N,EACJmB,MAAO,CACLxD,OAAQqP,EAAY,eAAYhN,GAElCiM,MAAO,iBAETnK,eAAeoC,EAAIxC,MAAM8L,qBAAsBzN,EAAQmE,GACvDvD,MAICyD,UAGT1C,EAAM0C,QAAQzE,KAAK8N,GACnB/L,EAAM2C,QAAQ1E,KAAK8N,GAGnBrJ,EAAQlD,QAAQ,SAAAnB,OACNF,EAAOE,EAAPF,GACRE,EAAO4N,OAASrB,EAAO9E,KAAK,SAAAU,UAAKA,EAAErI,KAAOA,IAC1CE,EAAO6N,YAActB,EAAOuB,UAAU,SAAA3F,UAAKA,EAAErI,KAAOA,IACpDE,EAAO+N,WAAa/N,EAAO4N,OAAS5N,EAAO4N,OAAOlP,UAAOuB,qBAsDtDW,GACHxB,KApDiB6D,cAAQ,cACrB0J,IAAkBJ,EAAO/N,cACpBY,EAELuE,GAAOmB,QAAQsB,KAAK,qBAElB4H,EAAwB,GAE9B3J,EACG9C,OAAO,SAAA0F,UAAOA,EAAIgH,aAClB9M,QAAQ,SAAA8F,GACP+G,EAAsB/G,EAAInH,IAAMmH,EAAIgH,oBAGvB,SAAXC,EAAW9O,OAIT+O,EAAanB,EACjB5N,EACAmN,EAAO/F,IAAI,SAAApI,OAEHgQ,EAAeJ,EAAsB5P,EAAK0B,WAGzC,SAAChB,EAAGC,UACRqP,GAAgB3B,GACf3N,EAAEW,OAAOrB,EAAK0B,IACdf,EAAEU,OAAOrB,EAAK0B,IACd1B,EAAKM,SAIX6N,EAAO/F,IAAI,SAAA2B,UAAMA,EAAEzJ,eAIrByP,EAAWhN,QAAQ,SAAA5B,GACZA,EAAImJ,UAGTnJ,EAAImJ,QAAUwF,EAAS3O,EAAImJ,YAGtByF,EAGFD,CAAS9O,IACf,CAACA,EAAMiF,EAASkI,EAAQI,OClP7BrK,aAAa+L,SAAW,GACxB/L,aAAagM,UAAY,EAEzB1F,WAAW,CACT2F,WAAY,mBAGd,IAAMjL,YAAY,CAEhBkL,iBAAkBhL,UAAUI,MAGjB6K,cAAgB,SAAA7N,GAC3B4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,qBAGrDxB,EAcEwB,EAdFxB,KACAoP,EAaE5N,EAbF4N,iBACA7K,EAYE/C,EAZF+C,uBAYE/C,EAXFmC,gBAEIsL,IAAAA,SACAC,IAAAA,UACWI,IAAXC,UACAhF,IAAAA,QACAxD,IAAAA,QACAoG,IAAAA,OAEFvJ,OAIJ4L,gBAAU,WACR5L,EACE,SAAAR,2BACKA,GACH8L,UAAW,KAEb3F,QAAQ4F,aAET,CAAC5E,EAASxD,EAASoG,UAEOtJ,cAAQ,cAC/BuL,QACK,CACLK,MAAO,CAACzP,GACRuP,UAAWD,GAGX/K,GAAOmB,QAAQsB,KAAK,oBAGlByI,EAAQzP,EAAKZ,OAAS,GAAK,CAAC,IAG9BZ,EAAS,EACNA,EAASwB,EAAKZ,QAAQ,KACrBsQ,EAAMlR,EAASyQ,EACrBQ,EAAMjP,KAAKR,EAAK2P,MAAMnR,EAAQkR,IAC9BlR,EAASkR,QAKJ,CACLD,MAAAA,EACAF,UAJgBE,EAAMrQ,OAKtBwQ,YAAAA,IAED,CAAC5P,EAAMiP,EAAUK,IA3BZG,IAAAA,MAAOF,IAAAA,UA6BTK,EAAc7Q,mBAAI,IAAIuB,MAAMiP,IAAYnI,IAAI,SAAC2B,EAAG5J,UAAMA,IACtD0Q,EAAOT,EAAmBpP,EAAOyP,EAAMP,IAAc,GAIrDY,EAAW,SAAAZ,UACX3K,GAAOmB,QAAQsB,KAAK,YACjBpD,EAAS,SAAAR,UACV8L,EAAY,GAAiBK,EAAY,EAAxBL,EACZ9L,mBAGJA,GACH8L,UAAAA,KAED3F,QAAQ4F,qCAwBR3N,GACHiO,MAAAA,EACAG,YAAAA,EACAC,KAAAA,EACAE,gBAzCkC,EAAZb,EA0CtBc,YAzCkBd,EAAYK,EAAY,EA0C1CO,SAAAA,EACAG,aA5BmB,kBACZH,EAASZ,EAAY,IA4B5BgB,SAzBe,kBACRJ,EAASZ,EAAY,IAyB5BiB,YAtBkB,SAAAlB,GAClBrL,EAAS,SAAAR,OACDgN,EAAchN,EAAI6L,SAAW7L,EAAI8L,kCAGlC9L,GACH8L,UAHgB3G,KAAK8H,MAAMD,EAAcnB,GAIzCA,SAAAA,KAED1F,QAAQ4G,iBC3GTjM,YAAY,CAChBoM,YAAalM,UAAUmM,QAGZC,cAAgB,SAAAhP,GAC3B4C,UAAUM,eAAeR,YAAW1C,EAAO,WAAY,uBAWnDA,EARF8O,YAAAA,aAAc,MAQZ9O,EAPFe,MACWkO,IAATxL,QACAK,IAAAA,YACAC,IAAAA,kBACAC,IAAAA,eACAC,IAAAA,oBAIJgL,EAAajQ,KAAK,SAACyE,EAASF,OACpB2L,EAAiBzL,EAAQ9C,OAAO,SAAAvB,UACpCA,EAAOuF,QACkB,mBAAhBvF,EAAOgI,KAAsBhI,EAAOgI,KAAK7D,KAASnE,EAAOgI,KAC3DhI,EAAOuF,UAGVwK,EAAqB,GAEvBC,EAAW,EACfF,EAAe3O,QAAQ,SAAAnB,SACOiQ,kBAC1BjQ,EACA0P,OACAzP,OACAA,EACAkE,GALM+L,IAAAA,MAAOC,IAAAA,SAQbH,GADEE,IAEOC,GAGGT,SAIVU,EAAY,CAChBhP,MAAO,CACLiP,QAAS,OACTF,mBAAaH,iBAIjB7L,EAAIiM,UAAYA,EAEhB1L,EAAY9E,KAAK,kBAAMwQ,IACvBzL,EAAkB/E,KAAK,kBAAMwQ,IAE7BxL,EAAehF,KAAK,SAAAI,SAAW,CAC7BoB,qBACEkP,UAAW,cACRC,mBAAmBvQ,EAAQ+P,EAAoBL,EAAavL,OAUnEU,EAAajF,KAAK,SAAA8F,SACT,CACLtE,qBACEiP,QAAS,QACTC,UAAW,cACRC,mBACD7K,EAAK1F,OACL+P,EACAL,OACAzP,EACAkE,OAYDE,IAGFzD,GAKT,SAAS2P,mBAAmBvQ,EAAQ+P,EAAoBL,EAAavL,SACjC8L,kBAChCjQ,EACA+P,EACAL,EACAvL,GAJMqM,IAAAA,KAAMN,IAAAA,MAAOO,IAAAA,eAOd,CACLD,eAASA,aACTN,gBAAUA,QACVO,mBAAaA,SAIjB,SAASR,oBAEPF,EACAL,EACAvL,OAHEE,IAAAA,QAASvE,IAAAA,GAAIoQ,IAAAA,MAAOC,IAAAA,SAAUM,IAAAA,gBAK5BpM,KACFA,EAAUA,EACPmC,IAAI,SAAAxG,UACHiQ,kBAAkBjQ,EAAQ+P,EAAoBL,EAAavL,KAE5D5C,OAAOC,UAEGhD,QAQN,CACLgS,KALWxO,IAAIqC,EAAQmC,IAAI,SAAAS,UAAOA,EAAIuJ,QAMtCN,MALYlO,IAAIqC,EAAQmC,IAAI,SAAAS,UAAOA,EAAIiJ,SAMvCO,SALezO,IAAIqC,EAAQmC,IAAI,SAAAS,UAAOA,EAAIwJ,aASvC,CACLD,KAAMN,EAAQ,EAAIR,EAClBQ,MACY,SAAVA,EACIH,EAAmBjQ,IAAO4P,EAC1BzQ,gBAAgBiR,EAAOC,EAAUT,GACvCe,SAAAA,OCtJSC,mBAAqB,gCACE5N,oBAA3B6N,OAAWC,wBACwB9N,oBAAnC+N,OAAeC,wBAC8BhO,eAAS,OAAtDiO,OAAoBC,wBACOlO,eAAS,MAApCwL,OAAW2C,OA4BZ9B,EAAkB4B,EAAmBvS,aAGpC,CACLsS,iBAAAA,EACAH,UAAAA,EACArC,UAAAA,EACAe,aAzBmB,WACnB4B,EAAa,SAAAzO,UAAOA,EAAM,IAC1BwO,EAAsB,SAAAxO,UACpBrE,mBAAIqE,GACD4E,UACA2H,MAAM,GACN3H,YAELwJ,EAAaG,EAAmBA,EAAmBvS,OAAS,KAkB5D8Q,SAhCe,WACf2B,EAAa,SAAAzO,UAAOA,EAAM,IAC1BwO,EAAsB,SAAAxO,sCAAWA,IAAKmO,MACtCC,EAAaC,IA8Bb1B,gBAAAA,EACAC,YATkByB,EAUlBK,gBAlBsB,WACtBN,OAAa3Q,GACbgR,EAAa,GACbH,OAAiB7Q,GACjB+Q,EAAsB"}